package de.tudortmund.cs.iltis.folalib.transform;

import java.io.Serializable;
import java.util.Objects;
import java.util.function.Function;

/**
 * Interface modeling the sum type of a set that was given as algorithm input and a set that was
 * generated by the algorithm.
 *
 * <p>For example, the transformation of a (right) regular grammar to a NFA generates one state for
 * each non terminal in the grammar, but also needs an additional state to act as the accepting
 * state. In this case, the grammar's non terminal as the {@code In} type, whereas the new accepted
 * state is of the type {@code Gen}. The resulting automaton will have states of type {@code
 * MaybeGenerated}.
 *
 * @param <In> The type of objects provided as algorithm input
 * @param <Gen> The type of objects additionally generated by the algorithm
 */
public interface MaybeGenerated<In, Gen> extends Serializable {
    <U> U match(Function<In, U> input, Function<Gen, U> generated);

    final class Input<In, Gen> implements MaybeGenerated<In, Gen> {
        private final In input;

        public Input(In input) {
            this.input = input;
        }

        // For GWT serialization
        private Input() {
            this(null);
        }

        @Override
        public <U> U match(Function<In, U> input, Function<Gen, U> generated) {
            return input.apply(this.input);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Input<?, ?> input1 = (Input<?, ?>) o;
            return input.equals(input1.input);
        }

        @Override
        public int hashCode() {
            return Objects.hash("input", input);
        }

        @Override
        public String toString() {
            return "In{" + input + '}';
        }
    }

    final class Generated<In, Gen> implements MaybeGenerated<In, Gen> {
        private final Gen generated;

        // For GWT serialization
        private Generated() {
            this(null);
        }

        public Generated(Gen generated) {
            this.generated = generated;
        }

        @Override
        public <U> U match(Function<In, U> input, Function<Gen, U> generated) {
            return generated.apply(this.generated);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Generated<?, ?> generated1 = (Generated<?, ?>) o;
            return generated.equals(generated1.generated);
        }

        @Override
        public int hashCode() {
            return Objects.hash("generated", generated);
        }

        @Override
        public String toString() {
            return "Gen{" + generated + '}';
        }
    }
}
