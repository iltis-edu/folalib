package de.tudortmund.cs.iltis.folalib.grammar.construction.builder;

import de.tudortmund.cs.iltis.folalib.grammar.Grammar;
import de.tudortmund.cs.iltis.folalib.grammar.construction.fault.GrammarConstructionFaultCollection;
import de.tudortmund.cs.iltis.folalib.grammar.construction.fault.GrammarConstructionFaultReason;
import de.tudortmund.cs.iltis.folalib.grammar.production.LeftRegularProduction;
import de.tudortmund.cs.iltis.folalib.languages.Alphabet;
import de.tudortmund.cs.iltis.utils.collections.Fault;
import java.io.Serializable;
import java.util.List;

/**
 * A left regular grammar is defined as follows: {X -> Ya, X -> a | X,Y ∈ V, a ∈ Σ} Additionally,
 * the production {S -> ɛ | S is start symbol} is allowed iff S occurs in no RHS of any production.
 */
public class LeftRegularGrammarBuilder<T extends Serializable, N extends Serializable>
        extends AbstractGrammarBuilder<
                T,
                N,
                LeftRegularProduction<T, N>,
                Grammar<T, N, LeftRegularProduction<T, N>>,
                LeftRegularGrammarBuilder<T, N>> {

    public LeftRegularGrammarBuilder(
            Alphabet<? extends T> terminals, Alphabet<? extends N> nonTerminals) {
        super(terminals, nonTerminals, Grammar::new);
    }

    public LeftRegularGrammarBuilder<T, N> withProduction(N lhs, T rhs) {
        return withProduction(new LeftRegularProduction<>(lhs, rhs));
    }

    public LeftRegularGrammarBuilder<T, N> withProduction(N lhs, N rhsNonTerminal, T rhsTerminal) {
        return withProduction(new LeftRegularProduction<>(lhs, rhsNonTerminal, rhsTerminal));
    }

    /**
     * Please note that a regular grammar only allows the epsilon-rule {S -> ɛ | S is start symbol}
     * iff S occurs in no RHS of any production. If this restriction is violated {@link
     * #validate()}, {@link #build()} and {@link #buildAndReset()} will fail.
     */
    public LeftRegularGrammarBuilder<T, N> withEpsProduction(N lhsNonTerminal) {
        return withProduction(new LeftRegularProduction<>(lhsNonTerminal));
    }

    /**
     * Additionally to the faults generated by {@link AbstractGrammarBuilder#validate()} the
     * following checks will be performed: It will check... ... if S -> ɛ is the only epsilon-rule
     * (if it exists) and if S does not occur in any RHS then {@link
     * GrammarConstructionFaultReason#THE_EPSILON_RULE}.
     *
     * @return A collection of all faults that were found.
     */
    @Override
    public GrammarConstructionFaultCollection validate() {
        List<Fault<GrammarConstructionFaultReason>> superFaults = super.validate().getFaults();

        superFaults.addAll(super.validateEpsilonRule().getFaults());

        return new GrammarConstructionFaultCollection(superFaults);
    }

    /** For serialization */
    @SuppressWarnings("unused")
    private LeftRegularGrammarBuilder() {}
}
